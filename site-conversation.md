<user>
I'm considering making a resume website for myself as an ai engineer and ai enablement specialist.
I want the base website to be very minimalist and stark and probably black and white, and then on it "see this website with" and then lovable, bolt, cursor, chatgpt, Claude code, v0, a bunch of different llm website makers, which will show the site as made by each technology, each will be much more fancy.
Can you help me make a technical plan for this; what would be the best way to do this; any suggestions appreciated 
</user>
<assistant> 
Love the concept. Here’s a practical, low‑maintenance way to build it so the **content is one source of truth** and each “made with X” version is a **fully isolated, fancy snapshot** that you can regenerate or swap out anytime.

---

## High‑level idea

* **One minimalist “shell” site** (your canonical resume) that’s black‑and‑white, blazing fast, and SEO/analytics friendly.
* **A single machine‑readable resume** (JSON) that all versions consume.
* **Multiple isolated “variant” builds**—each one “as made by” Lovable, Bolt, Cursor, ChatGPT, Claude Code, v0, etc. These live as static HTML/CSS/JS bundles in your repo.
* On the shell, a **toggle/selector**: “See this site made with…”. Selecting a tool swaps in that variant inside a sandboxed `<iframe>` (or opens a dedicated `/with/<tool>` route). Because each variant is isolated, its CSS/JS can be as wild as it wants without breaking the shell.

This gets you:

* **Consistency** (same resume data everywhere)
* **Safety** (no CSS/JS collisions)
* **Performance** (shell stays fast; variants prefetched)
* **Credibility** (each variant is a real artifact generated by the named tool)

---

## Recommended stack (tailored to you)

You’re comfortable with AWS & Svelte. Keep it simple and robust:

* **Framework (Shell):** SvelteKit with `adapter-static` (SSG). Zero/near‑zero JS on the shell.
* **Data:** [JSON Resume schema](https://jsonresume.org/) (extensible). Store it as `/static/data/resume.json`.
* **Variants:** Plain static bundles (generated by each AI tool). One folder per tool: `/static/variants/<tool>/index.html` (+ assets).
* **Hosting:** S3 + CloudFront via SST (since you know AWS well), or Cloudflare Pages if you want an even simpler DX.
* **CI/CD:** GitHub Actions. On `main`, build shell and deploy. Variants are static files—no build step needed beyond copy.
* **Analytics:** Plausible/Umami (lightweight, privacy‑respecting) only on the shell.
* **SEO:** Canonical URLs and `noindex` for variant routes.

---

## Information architecture & routing

* Shell (SvelteKit):

  * `/` — minimal B\&W resume (canonical)
  * `/with/[tool]` — loads variant via iframe (same‑origin)
  * `/data/resume.json` — source‑of‑truth resume
* Variants (static):

  * `/variants/lovable/index.html`
  * `/variants/bolt/index.html`
  * `/variants/cursor/index.html`
  * `/variants/chatgpt/index.html`
  * `/variants/claude-code/index.html`
  * `/variants/v0/index.html`
  * …and so on

**Why iframe?** Absolute CSS/JS isolation, fewer surprises, easy drop‑in replacement, and you can show a small header above the frame with the tool’s name, date generated, and the prompt used.

---

## Repo layout

```
resume-site/
├─ apps/
│  └─ shell/                      # SvelteKit app (the minimal site)
│     ├─ src/
│     │  ├─ lib/
│     │  │  ├─ providers.ts       # List of “tools”, display names, paths
│     │  │  └─ components/
│     │  │     └─ VariantFrame.svelte
│     │  └─ routes/
│     │     ├─ +layout.svelte
│     │     ├─ +page.svelte       # Minimal resume view
│     │     └─ with/
│     │        └─ [tool]/
│     │           └─ +page.svelte  # iframe wrapper
│     └─ static/
│        ├─ data/resume.json       # JSON Resume (single source of truth)
│        └─ variants/
│           ├─ lovable/...
│           ├─ bolt/...
│           ├─ cursor/...
│           ├─ chatgpt/...
│           ├─ claude-code/...
│           └─ v0/...
├─ scripts/
│  ├─ validate-variant.mjs         # HTML/CSS lint, link check
│  └─ generate-from-llm/           # Optional: auto-regeneration helpers
└─ .github/workflows/deploy.yml
```

---

## The data model (JSON Resume)

* Start with JSON Resume core fields: `basics`, `work`, `education`, `projects`, `skills`, etc.
* Add a **small extension** block for your AI‑enablement portfolio:

  ```json
  {
    "aiShowcase": [
      {
        "title": "AI Enablement Playbook @ Org",
        "summary": "Rolled out prompt ops, evals, and governance; reduced cycle time by 38%.",
        "tech": ["OpenAI", "Anthropic", "LangChain", "Weights & Biases"],
        "links": [{"title": "Case Study", "url": "https://..."}]
      }
    ]
  }
  ```

All shell & variants derive from the same JSON.

---

## Shell UI behavior

* At the top/right: `See this website made with: [Minimal] [Lovable] [Bolt] [Cursor] [ChatGPT] [Claude Code] [v0]`
* Selecting a provider:

  * Navigates to `/with/<tool>`
  * Preloads `/variants/<tool>/index.html` (link prefetch + Service Worker optional)
* Above the iframe, show:

  * Tool name & badge
  * “Generated on <date> from commit <hash>” (links to repo folder)
  * Prompt used (expandable), with note: “Not affiliated with <Tool>.”

**Accessibility & performance**

* High contrast, semantic HTML, skip links, reduced‑motion support.
* No custom fonts on the shell; system stack only.
* Strict CSP; iframe uses `sandbox` with only what’s required:

  * `sandbox="allow-scripts allow-same-origin"` (add `allow-popups` if a variant needs it)

---

## Sample code (SvelteKit shell)

**`src/lib/providers.ts`**

```ts
export type Provider = {
  id: string;
  name: string;
  path: string;     // relative to site root
  color?: string;   // optional accent for the label only (not global styling)
  noindex?: boolean;
};

export const PROVIDERS: Provider[] = [
  { id: 'minimal', name: 'Minimal', path: '/'},
  { id: 'lovable', name: 'Lovable', path: '/variants/lovable/index.html' },
  { id: 'bolt', name: 'Bolt', path: '/variants/bolt/index.html' },
  { id: 'cursor', name: 'Cursor', path: '/variants/cursor/index.html' },
  { id: 'chatgpt', name: 'ChatGPT', path: '/variants/chatgpt/index.html' },
  { id: 'claude-code', name: 'Claude Code', path: '/variants/claude-code/index.html' },
  { id: 'v0', name: 'v0', path: '/variants/v0/index.html' }
];
```

**`src/lib/components/VariantFrame.svelte`**

```svelte
<script lang="ts">
  export let src: string;
  // Optional: listen for height messages if a variant posts its height
  let height = '80vh';
  function handleMessage(e: MessageEvent) {
    if (typeof e.data === 'object' && e.data?.type === 'variant:height') {
      const h = Number(e.data.value);
      if (!Number.isNaN(h) && h > 300) height = `${h}px`;
    }
  }
  if (typeof window !== 'undefined') {
    window.addEventListener('message', handleMessage);
  }
</script>

<iframe
  title="Variant preview"
  src={src}
  style={`width:100%;border:1px solid #e5e5e5;border-radius:8px;height:${height};`}
  sandbox="allow-scripts allow-same-origin"
  loading="lazy"
></iframe>
```

**`src/routes/with/[tool]/+page.svelte`**

```svelte
<script lang="ts">
  import { PROVIDERS } from '$lib/providers';
  import VariantFrame from '$lib/components/VariantFrame.svelte';
  export let data;
  const provider = PROVIDERS.find(p => p.id === data.tool);
  const isMinimal = provider?.id === 'minimal';
</script>

<svelte:head>
  {#if provider?.noindex}
    <meta name="robots" content="noindex, nofollow" />
  {/if}
  <link rel="prefetch" href={provider?.path} />
</svelte:head>

{#if !provider}
  <h1>Unknown provider</h1>
{:else}
  <header style="display:flex;justify-content:space-between;align-items:center;margin:1rem 0;">
    <h1 style="font-size:1rem;font-weight:600;">Made with {provider.name}</h1>
    <nav aria-label="Variants" style="display:flex;gap:.5rem;flex-wrap:wrap;">
      {#each PROVIDERS as p}
        <a href={`/with/${p.id}`}
           style="text-decoration:none;border:1px solid #ddd;padding:.3rem .6rem;border-radius:6px;font-size:.9rem;">
          {p.name}
        </a>
      {/each}
    </nav>
  </header>

  {#if isMinimal}
    <p>This route is for variants; the Minimal version is the home page.</p>
  {:else}
    <VariantFrame src={provider.path} />
  {/if}
{/if}
```

**`src/routes/with/[tool]/+page.ts`**

```ts
import type { PageLoad } from './$types';
export const load: PageLoad = ({ params }) => ({ tool: params.tool });
```

**Home page (`src/routes/+page.svelte`)**

* Render your B\&W resume directly from `/data/resume.json`.
* Keep it semantic and tiny (e.g., fetch in `load()` and render; or embed at build time).

---

## Creating each variant (the fun part)

For each tool (Lovable, Bolt, Cursor, ChatGPT, Claude Code, v0):

1. **Prompt shape (keep consistent)**

   * Provide the JSON Resume (paste or link to `/data/resume.json`).
   * Ask for **a single, production‑ready HTML file** + inline CSS/JS, or a tiny asset folder.
   * Requirements:

     * Read resume from `/data/resume.json` via `fetch`.
     * Do not use external fonts or trackers.
     * Namespaced CSS (e.g., wrap in `#app-<tool>` or use BEM) to minimize any chance of leaks.
     * Include a small `postMessage({ type: 'variant:height', value: document.body.scrollHeight })` after render so the iframe can auto‑size (optional).
     * Lighthouse performance ≥ 90 on mobile.

2. **Export the artifact**

   * Save exactly what the tool gives you into `/static/variants/<tool>/`.
   * If the tool gives a project, run its build once and copy the `dist` (flatten if needed).

3. **Validate**

   * `scripts/validate-variant.mjs` runs:

     * `html-validate`/`eslint-plugin-html`
     * dead link check
     * Lighthouse CI (optional) to a minimum budget

4. **Annotate**

   * In your repo’s `README.md` for each variant folder, record:

     * Tool name & version
     * Date generated
     * The exact prompt (so viewers can reproduce)
     * Any manual tweaks you made

> Tip: Freeze a variant per commit. If you regenerate with the same tool later, keep both (`/variants/<tool>-2025-08-28/`), and point `/variants/<tool>/` to the latest with a CI step.

---

## Prefetch & performance

* Add `<link rel="prefetch" href="/variants/<tool>/index.html">` for the currently highlighted option (or for all once idle).
* Optional Service Worker: on first visit, cache the variants so the toggling feels instantaneous offline.
* Keep variants same‑origin (served from your domain) so iframes can postMessage height and prefetch works cleanly.

---

## SEO & legal niceties

* The **shell** is your canonical resume. Use `<link rel="canonical" href="https://yoursite/">`.
* Add `<meta name="robots" content="noindex, nofollow">` for `/with/*` pages (or just the iframe pages) to avoid duplicate content.
* **Not affiliated** disclaimer above each iframe: “This demo variant was generated with <Tool>. Logos and names are trademarks of their respective owners.”

---

## Deployment with SST (sketch)

* **Infra**: S3 Website Bucket (static hosting disabled; serve via CloudFront + OAC), CloudFront distribution, Route53 DNS, ACM certificate.
* **CI**: GitHub Actions

  * Job 1: build SvelteKit shell → `build/` folder
  * Job 2: copy `apps/shell/build/**` + `apps/shell/static/**` (which includes `data/` and `variants/`) to S3
  * Invalidate CloudFront on changed paths (`/index.html`, `/with/*`, `/variants/*`, `/data/resume.json`)

---

## Optional “Regenerate with AI” pipeline

If you want the site to **self‑refresh variants** when `resume.json` changes:

* Add a small serverless function (API Gateway + Lambda via SST) that:

  * Pulls `resume.json`
  * Calls the provider’s API (OpenAI/Anthropic/Vercel v0, etc.) with your standard prompt
  * Validates output and writes to S3 under `/variants/<tool>/`
* Gate this behind an **admin-only** secret URL and run it manually (or on CI).

Pros: always up‑to‑date variants.
Cons: needs API keys & careful guardrails; sometimes LLMs drift from constraints.

---

## QA & guardrails checklist

* [ ] Lighthouse ≥ 95 (shell), ≥ 90 (variants)
* [ ] Axe a11y pass (shell) and basic checks (variants)
* [ ] 3 device sizes tested (360w, 768w, 1280w)
* [ ] No external calls in variants except `/data/resume.json`
* [ ] CSP for shell (`default-src 'self'`), iframe `sandbox` enabled
* [ ] Analytics only on shell
* [ ] Robots `noindex` on `/with/*`
* [ ] 404 for unknown `/with/<tool>`

---

## Small touches that impress

* **“Diff view”**: on the shell, show a tiny modal with the exact prompt used for a variant (read from a `PROMPT.md` file in each variant folder).
* **Performance badge**: Pull Lighthouse scores (CI artifact) and show a badge near each tool name (“Perf 97, A11y 98”).
* **Keyboard‑first UX**: `[` and `]` keys cycle variants.
* **Print stylesheet**: The shell prints to one page cleanly.

---

## Suggested implementation order (2–4 evenings)

1. **Set up shell** (SvelteKit static) + JSON resume + minimal B\&W render.
2. **Wire `/with/[tool]`** route and `<iframe>` component.
3. **Add 2 variants** (e.g., ChatGPT and Claude Code) by hand, validate.
4. **Prefetch + postMessage height** for smooth UX.
5. **Infra** via SST and first deploy to your domain.
6. Add remaining variants, QA, and polish (badges, prompts modal).

---

If you want, I can:

* Draft the minimal shell page that renders from `resume.json`.
* Write the `providers.ts`, `VariantFrame.svelte`, and a small validate script.
* Give you a reproducible **prompt template** you can paste into each tool to generate consistent, high‑quality variants.
</assistant>

<user>
Yes please. Go ahead and do that 
</user>
<assistant>
Awesome — here’s a **ready-to-drop** SvelteKit scaffold (minimal shell + provider switcher), a **validator script** for variants, a **sample variant**, and a **prompt template** you can paste into Lovable/Bolt/Cursor/ChatGPT/Claude Code/v0 to generate each fancy version.

> **What you get below**
>
> 1. Minimal B\&W shell site that renders from `static/data/resume.json`
> 2. `/with/[tool]` route that sandboxes each “made with X” variant in an iframe
> 3. `scripts/validate-variant.mjs` to lint/verify variants
> 4. A sample `chatgpt/` variant to prove the plumbing
> 5. A reproducible prompt template for generating more variants

---

## 0) Quick start

```bash
# 1) Create SvelteKit project
npm create svelte@latest resume-site
cd resume-site

# 2) Add dependencies
npm i
npm i -D @sveltejs/adapter-static html-validate cheerio typescript svelte-check @types/node

# 3) Replace/add the files below into this repo
#    (copy the file tree & contents exactly)

# 4) Run it
npm run dev

# 5) Build static site (for S3/CloudFront etc.)
npm run build

# (Optional) Validate variants
npm run validate:variants
```

---

## 1) File tree

```
resume-site/
├─ package.json
├─ svelte.config.js
├─ tsconfig.json
├─ vite.config.ts
├─ scripts/
│  └─ validate-variant.mjs
├─ static/
│  ├─ data/
│  │  └─ resume.json
│  └─ variants/
│     └─ chatgpt/
│        └─ index.html
└─ src/
   ├─ app.html
   ├─ lib/
   │  ├─ providers.ts
   │  └─ components/
   │     └─ VariantFrame.svelte
   └─ routes/
      ├─ +layout.svelte
      ├─ +page.ts
      ├─ +page.svelte
      ├─ robots.txt/
      │  └─ +server.ts
      └─ with/
         └─ [tool]/
            ├─ +page.ts
            └─ +page.svelte
```

---

## 2) Code — drop in exactly

### `package.json`

```json
{
  "name": "resume-site",
  "version": "0.0.1",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite dev",
    "build": "vite build",
    "preview": "vite preview",
    "check": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json",
    "validate:variants": "node scripts/validate-variant.mjs"
  },
  "devDependencies": {
    "@sveltejs/adapter-static": "^3.0.2",
    "@sveltejs/kit": "^2.5.10",
    "@types/node": "^20.12.12",
    "cheerio": "^1.0.0",
    "html-validate": "^9.1.3",
    "svelte": "^4.2.18",
    "svelte-check": "^3.6.7",
    "tslib": "^2.6.2",
    "typescript": "^5.4.5",
    "vite": "^5.4.2"
  }
}
```

### `svelte.config.js`

```js
import adapter from '@sveltejs/adapter-static';

/** @type {import('@sveltejs/kit').Config} */
const config = {
  kit: {
    adapter: adapter(),
    prerender: { entries: ['*'] }
  }
};

export default config;
```

### `tsconfig.json`

```json
{
  "extends": "./.svelte-kit/tsconfig.json",
  "compilerOptions": {
    "types": ["svelte"],
    "moduleResolution": "bundler",
    "strict": true
  }
}
```

### `vite.config.ts`

```ts
import { sveltekit } from '@sveltejs/kit/vite';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [sveltekit()]
});
```

### `src/app.html`

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="data:," />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="color-scheme" content="light" />
    %sveltekit.head%
    <style>
      /* Minimal, high-contrast defaults (no custom fonts) */
      :root {
        --fg: #111;
        --bg: #fff;
        --muted: #666;
        --border: #e5e5e5;
        --accent: #000;
      }
      * { box-sizing: border-box; }
      html, body { padding: 0; margin: 0; background: var(--bg); color: var(--fg); }
      a { color: var(--accent); }
      code, pre { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    </style>
  </head>
  <body>
    <div style="position:fixed;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden;">
      <a href="#content">Skip to content</a>
    </div>
    %sveltekit.body%
  </body>
</html>
```

### `src/lib/providers.ts`

```ts
export type Provider = {
  id: string;
  name: string;
  path: string;        // static path to variant entry
  noindex?: boolean;   // whether to add robots noindex on /with/[tool]
};

export const PROVIDERS: Provider[] = [
  { id: 'minimal', name: 'Minimal', path: '/' },
  { id: 'lovable', name: 'Lovable', path: '/variants/lovable/index.html', noindex: true },
  { id: 'bolt', name: 'Bolt', path: '/variants/bolt/index.html', noindex: true },
  { id: 'cursor', name: 'Cursor', path: '/variants/cursor/index.html', noindex: true },
  { id: 'chatgpt', name: 'ChatGPT', path: '/variants/chatgpt/index.html', noindex: true },
  { id: 'claude-code', name: 'Claude Code', path: '/variants/claude-code/index.html', noindex: true },
  { id: 'v0', name: 'v0', path: '/variants/v0/index.html', noindex: true }
];
```

### `src/lib/components/VariantFrame.svelte`

```svelte
<script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  export let src: string;
  let height = '80vh';

  function onMessage(e: MessageEvent) {
    const d = e?.data;
    if (d && typeof d === 'object' && d.type === 'variant:height') {
      const h = Number(d.value);
      if (!Number.isNaN(h) && h > 300) height = `${h}px`;
    }
  }

  onMount(() => window.addEventListener('message', onMessage));
  onDestroy(() => window.removeEventListener('message', onMessage));
</script>

<iframe
  title="Variant preview"
  src={src}
  style={`width:100%;height:${height};border:1px solid #e5e5e5;border-radius:8px;background:#fff;`}
  loading="lazy"
  sandbox="allow-scripts allow-same-origin"
></iframe>
```

### `src/routes/+layout.svelte`

```svelte
<script>
  // Global shell nav & layout
</script>

<header style="padding:1rem;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:center;">
  <a href="/" style="text-decoration:none;color:inherit;font-weight:700">Your Name — AI Engineer & Enablement</a>
  <nav aria-label="Primary" style="display:flex;gap:.75rem;">
    <a href="/" style="text-decoration:none;">Home</a>
    <a href="/with/chatgpt" style="text-decoration:none;">Made with ChatGPT</a>
  </nav>
</header>

<main id="content" style="max-width:900px;margin:0 auto;padding:1.25rem;">
  <slot />
</main>

<footer style="max-width:900px;margin:2rem auto 3rem;padding:0 1.25rem;color:var(--muted);font-size:.9rem;">
  <p>Variants are demos; trademarks belong to their owners. Canonical content is the minimal version.</p>
</footer>
```

### `src/routes/+page.ts`

```ts
import type { PageLoad } from './$types';

export const prerender = true;

export const load: PageLoad = async ({ fetch }) => {
  const res = await fetch('/data/resume.json');
  if (!res.ok) throw new Error('Failed to load resume.json');
  const resume = await res.json();
  return { resume };
};
```

### `src/routes/+page.svelte`

```svelte
<script lang="ts">
  export let data: any;
  const resume = data.resume;

  const contactLinks = [
    resume.basics?.website && { label: 'Website', url: resume.basics.website },
    resume.basics?.email && { label: resume.basics.email, url: `mailto:${resume.basics.email}` },
    resume.basics?.location?.city && { label: resume.basics.location.city, url: null },
    resume.basics?.profiles?.find((p:any)=>p.network?.toLowerCase()==='github') && {
      label: 'GitHub',
      url: resume.basics.profiles.find((p:any)=>p.network?.toLowerCase()==='github').url
    },
    resume.basics?.profiles?.find((p:any)=>p.network?.toLowerCase()==='linkedin') && {
      label: 'LinkedIn',
      url: resume.basics.profiles.find((p:any)=>p.network?.toLowerCase()==='linkedin').url
    }
  ].filter(Boolean) as {label:string,url:string|null}[];
</script>

<section aria-labelledby="title">
  <h1 id="title" style="font-size:2rem;line-height:1.1;margin:.25rem 0 .5rem 0;">
    {resume.basics?.name || 'Your Name'}
  </h1>
  <p style="margin:0;color:var(--muted);">{resume.basics?.label || 'AI Engineer · AI Enablement Specialist'}</p>
  {#if contactLinks.length}
    <ul style="list-style:none;padding:0;margin:.75rem 0 0 0;display:flex;gap:1rem;flex-wrap:wrap;">
      {#each contactLinks as c}
        <li>
          {#if c.url}
            <a href={c.url} rel="noopener noreferrer">{c.label}</a>
          {:else}
            <span>{c.label}</span>
          {/if}
        </li>
      {/each}
    </ul>
  {/if}
</section>

<hr style="margin:1.25rem 0;border:0;border-top:1px solid var(--border);" />

{#if resume.basics?.summary}
  <section aria-labelledby="summary">
    <h2 id="summary" style="font-size:1rem;text-transform:uppercase;letter-spacing:.06em;margin-bottom:.5rem;">Summary</h2>
    <p style="margin:0;max-width:70ch;">{resume.basics.summary}</p>
  </section>

  <hr style="margin:1.25rem 0;border:0;border-top:1px solid var(--border);" />
{/if}

{#if resume.work?.length}
  <section aria-labelledby="work">
    <h2 id="work" style="font-size:1rem;text-transform:uppercase;letter-spacing:.06em;margin-bottom:.5rem;">Experience</h2>
    {#each resume.work as job (job.name + job.position)}
      <article style="margin-bottom:1rem;">
        <div style="display:flex;justify-content:space-between;gap:1rem;flex-wrap:wrap;">
          <div>
            <strong>{job.position}</strong>{' @ '}{job.name}
          </div>
          <div style="color:var(--muted);">
            {job.startDate}{job.endDate ? ` – ${job.endDate}` : ' – Present'}
          </div>
        </div>
        {#if job.summary}<p style="margin:.25rem 0 0 0;max-width:70ch;">{job.summary}</p>{/if}
        {#if job.highlights?.length}
          <ul style="margin:.25rem 0 0 1rem;">
            {#each job.highlights as h}<li>{h}</li>{/each}
          </ul>
        {/if}
      </article>
    {/each}
  </section>

  <hr style="margin:1.25rem 0;border:0;border-top:1px solid var(--border);" />
{/if}

{#if resume.projects?.length}
  <section aria-labelledby="projects">
    <h2 id="projects" style="font-size:1rem;text-transform:uppercase;letter-spacing:.06em;margin-bottom:.5rem;">Projects</h2>
    <ul style="list-style:disc;margin:.25rem 0 0 1rem;">
      {#each resume.projects as p}
        <li>
          <strong>{p.name}</strong>{p.url ? ' — ' : ''}{#if p.url}<a rel="noopener noreferrer" href={p.url}>{p.url}</a>{/if}
          {#if p.description}<div style="margin:.25rem 0 0 0;max-width:70ch;">{p.description}</div>{/if}
          {#if p.keywords?.length}<div style="color:var(--muted);font-size:.9rem;margin-top:.25rem;">{p.keywords.join(' · ')}</div>{/if}
        </li>
      {/each}
    </ul>
  </section>

  <hr style="margin:1.25rem 0;border:0;border-top:1px solid var(--border);" />
{/if}

{#if resume.skills?.length}
  <section aria-labelledby="skills">
    <h2 id="skills" style="font-size:1rem;text-transform:uppercase;letter-spacing:.06em;margin-bottom:.5rem;">Skills</h2>
    <ul style="list-style:none;padding:0;margin:0;display:flex;flex-wrap:wrap;gap:.5rem;">
      {#each resume.skills as s}
        <li style="border:1px solid var(--border);padding:.25rem .5rem;border-radius:999px;">
          {s.name}{s.keywords?.length ? ` — ${s.keywords.join(', ')}` : ''}
        </li>
      {/each}
    </ul>
  </section>
{/if}
```

### `src/routes/robots.txt/+server.ts`

```ts
import type { RequestHandler } from '@sveltejs/kit';

export const GET: RequestHandler = () => {
  const body = [
    'User-agent: *',
    'Allow: /',
    'Disallow: /with/',
    'Sitemap: /sitemap.xml' // optional; remove if not generating one
  ].join('\n');

  return new Response(body, {
    headers: {
      'content-type': 'text/plain; charset=utf-8',
      'cache-control': 'public, max-age=3600'
    }
  });
};
```

### `src/routes/with/[tool]/+page.ts`

```ts
import type { PageLoad } from './$types';
import { PROVIDERS } from '$lib/providers';

export const prerender = true;

export const load: PageLoad = async ({ params }) => {
  const provider = PROVIDERS.find((p) => p.id === params.tool);
  return {
    provider,
    providers: PROVIDERS
  };
};
```

### `src/routes/with/[tool]/+page.svelte`

```svelte
<script lang="ts">
  import { onMount } from 'svelte';
  import { PROVIDERS } from '$lib/providers';
  import VariantFrame from '$lib/components/VariantFrame.svelte';

  export let data: { provider: any; providers: typeof PROVIDERS };

  const p = data.provider;
  const providers = data.providers;
  const idx = providers.findIndex((x) => x.id === p?.id);

  function goto(id: string) {
    window.location.href = id === 'minimal' ? '/' : `/with/${id}`;
  }

  // Keyboard: [ ] to cycle
  function onKey(e: KeyboardEvent) {
    if (!p) return;
    if (e.key === ']') {
      const next = providers[(idx + 1) % providers.length];
      goto(next.id);
    } else if (e.key === '[') {
      const prev = providers[(idx - 1 + providers.length) % providers.length];
      goto(prev.id);
    }
  }

  onMount(() => window.addEventListener('keydown', onKey));
</script>

<svelte:head>
  {#if p?.noindex}<meta name="robots" content="noindex, nofollow" />{/if}
  {#if p?.path}<link rel="prefetch" href={p.path} />{/if}
</svelte:head>

{#if !p}
  <h1>Unknown provider</h1>
{:else}
  <header style="display:flex;justify-content:space-between;align-items:center;margin:1rem 0;">
    <div>
      <h1 style="font-size:1rem;margin:.25rem 0;">Made with {p.name}</h1>
      <p style="margin:0;color:var(--muted);font-size:.9rem;">Demo variant generated by {p.name}. Not affiliated.</p>
    </div>
    <nav aria-label="Variants" style="display:flex;gap:.5rem;flex-wrap:wrap;">
      {#each providers as pv}
        <a href={pv.id === 'minimal' ? '/' : `/with/${pv.id}`}
           style="text-decoration:none;border:1px solid var(--border);padding:.3rem .6rem;border-radius:6px;font-size:.9rem;">
          {pv.name}
        </a>
      {/each}
    </nav>
  </header>

  {#if p.id === 'minimal'}
    <p>This route previews variants. The minimal version is the home page.</p>
  {:else}
    <VariantFrame src={p.path} />
  {/if}
{/if}
```

---

## 3) Variant validator script

### `scripts/validate-variant.mjs`

```js
import fs from 'node:fs/promises';
import path from 'node:path';
import { HtmlValidate } from 'html-validate';
import * as cheerio from 'cheerio';

const ROOT = path.resolve(process.cwd());
const VARIANTS_DIR = path.join(ROOT, 'static', 'variants');

const validator = new HtmlValidate({
  extends: ['html-validate:recommended'],
  rules: {
    'no-dup-class': 'error',
    'no-trailing-whitespace': 'warn',
    // Allow inline styles; variants are self-contained
    'no-inline-style': 'off'
  }
});

async function validateVariant(dir) {
  const entry = path.join(VARIANTS_DIR, dir, 'index.html');
  const html = await fs.readFile(entry, 'utf8');

  // 1) HTML semantics
  const result = validator.validateString(html);
  if (!result.valid) {
    console.error(`✖ ${dir}: HTML validation failed`);
    result.results.forEach((r) =>
      r.messages.forEach((m) =>
        console.error(`  ${m.ruleId} [${m.severity}] ${m.message} @ line ${m.line}:${m.column}`)
      )
    );
    throw new Error('HTML validation failed');
  }

  // 2) Minimal policy checks
  const hasFetchResume = /fetch\(['"`]\/data\/resume\.json['"`]\)/.test(html);
  if (!hasFetchResume) {
    console.warn(`! ${dir}: Did not find fetch('/data/resume.json') — ensure variant reads the shared resume data`);
  }

  const hasPostMessage = /postMessage\s*\(\s*\{\s*type\s*:\s*['"`]variant:height['"`]/.test(html);
  if (!hasPostMessage) {
    console.warn(`! ${dir}: No postMessage({ type: 'variant:height', ... }) — iframe may not auto-size`);
  }

  // 3) Basic link checks for local assets
  const $ = cheerio.load(html);
  const assetPaths = [];
  $('link[href], script[src], img[src]').each((_, el) => {
    const attr = el.name === 'link' ? 'href' : 'src';
    const url = $(el).attr(attr);
    if (!url) return;
    if (url.startsWith('http')) return; // allow external (discouraged but not blocked)
    const abs = path.join(VARIANTS_DIR, dir, url.replace(/^\//, '')); // treat root as /static
    assetPaths.push(abs);
  });
  for (const p of assetPaths) {
    try {
      await fs.access(p);
    } catch {
      console.warn(`! ${dir}: Missing local asset referenced by HTML -> ${p}`);
    }
  }

  console.log(`✔ ${dir}: OK`);
}

async function main() {
  const entries = await fs.readdir(VARIANTS_DIR, { withFileTypes: true }).catch(() => []);
  const dirs = entries.filter((d) => d.isDirectory()).map((d) => d.name);
  if (!dirs.length) {
    console.log('No variants found in static/variants. Add at least one folder.');
    return;
  }
  for (const d of dirs) await validateVariant(d);
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
```

---

## 4) Sample shared resume data

> **Edit this** with your content; it follows the JSON Resume schema (plus a small `aiShowcase` extension).

### `static/data/resume.json`

```json
{
  "basics": {
    "name": "Your Name",
    "label": "AI Engineer · AI Enablement Specialist",
    "email": "you@example.com",
    "website": "https://yourdomain.com",
    "location": { "city": "City, Country" },
    "summary": "AI engineer focused on LLM app delivery, enablement, and governance. I help teams ship safe, observable, and cost-effective AI features.",
    "profiles": [
      { "network": "GitHub", "username": "yourgithub", "url": "https://github.com/yourgithub" },
      { "network": "LinkedIn", "username": "yourlinkedin", "url": "https://www.linkedin.com/in/yourlinkedin/" }
    ]
  },
  "work": [
    {
      "name": "Company A",
      "position": "Senior AI Engineer",
      "startDate": "2023-04",
      "endDate": "",
      "summary": "Lead LLM platform & enablement.",
      "highlights": [
        "Shipped retrieval-augmented generation with evals >92% exact-match",
        "Cut inference cost 37% via caching & prompt compression",
        "Rolled out prompt ops, guardrails, and incident response playbook"
      ]
    }
  ],
  "projects": [
    {
      "name": "AI Enablement Toolkit",
      "description": "Templates for evals, guardrails, and observability on Langfuse/W&B.",
      "url": "https://yourdomain.com/ai-toolkit",
      "keywords": ["Evals", "Guardrails", "Observability", "PromptOps"]
    }
  ],
  "skills": [
    { "name": "LLMs", "keywords": ["OpenAI", "Anthropic", "Ollama", "vLLM"] },
    { "name": "Platform", "keywords": ["AWS", "SST", "S3/CloudFront", "Lambda", "SageMaker"] },
    { "name": "Data", "keywords": ["Snowflake", "dbt", "Databricks", "Airflow"] },
    { "name": "App", "keywords": ["SvelteKit", "React", "Vite", "TypeScript"] }
  ],
  "aiShowcase": [
    {
      "title": "Enablement @ Org",
      "summary": "Ship fast with evals & governance; reduced cycle time 38%.",
      "tech": ["OpenAI", "Anthropic", "LangChain", "W&B"],
      "links": [{ "title": "Case Study", "url": "https://yourdomain.com/case-study" }]
    }
  ]
}
```

---

## 5) Sample variant (ChatGPT) to test

> Put every generated variant under `static/variants/<tool>/index.html`.
> This sample fetches `/data/resume.json` and posts its height for smooth iframe sizing.

### `static/variants/chatgpt/index.html`

```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Resume — ChatGPT Variant</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    /* Namespaced styles to avoid leaking */
    #app-chatgpt { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif; background:#fafafa; color:#111; padding:16px; }
    #app-chatgpt .card { background:#fff; border:1px solid #e5e5e5; border-radius:12px; padding:16px; margin:12px 0; box-shadow:0 1px 0 rgba(0,0,0,.03); }
    #app-chatgpt h1 { font-size:28px; margin:0 0 6px 0; }
    #app-chatgpt h2 { font-size:14px; letter-spacing:.06em; text-transform:uppercase; margin:16px 0 8px; color:#555; }
    #app-chatgpt .chips { display:flex; flex-wrap:wrap; gap:8px; }
    #app-chatgpt .chip { border:1px solid #e5e5e5; border-radius:999px; padding:4px 8px; font-size:12px; }
    #app-chatgpt a { color:#0b62ff; text-decoration:none; }
  </style>
</head>
<body>
  <div id="app-chatgpt">
    <div class="card" id="header">
      <h1 id="name">Loading…</h1>
      <div id="label" style="color:#555;"></div>
      <div id="links" style="margin-top:6px; display:flex; gap:12px; flex-wrap:wrap;"></div>
    </div>

    <div class="card">
      <h2>Summary</h2>
      <div id="summary"></div>
    </div>

    <div class="card">
      <h2>Experience</h2>
      <div id="work"></div>
    </div>

    <div class="card">
      <h2>Skills</h2>
      <div id="skills" class="chips"></div>
    </div>
  </div>

  <script>
    async function render() {
      const res = await fetch('/data/resume.json');
      const data = await res.json();

      const byId = (id) => document.getElementById(id);
      byId('name').textContent = data.basics?.name || 'Your Name';
      byId('label').textContent = data.basics?.label || '';
      const links = [];
      if (data.basics?.website) links.push(`<a href="${data.basics.website}" target="_blank" rel="noopener">Website</a>`);
      if (data.basics?.email) links.push(`<a href="mailto:${data.basics.email}">${data.basics.email}</a>`);
      const gh = data.basics?.profiles?.find(p => (p.network||'').toLowerCase()==='github');
      if (gh) links.push(`<a href="${gh.url}" target="_blank" rel="noopener">GitHub</a>`);
      const li = data.basics?.profiles?.find(p => (p.network||'').toLowerCase()==='linkedin');
      if (li) links.push(`<a href="${li.url}" target="_blank" rel="noopener">LinkedIn</a>`);
      byId('links').innerHTML = links.join(' · ');

      byId('summary').textContent = data.basics?.summary || '';

      const work = (data.work||[]).map(j => {
        const when = j.endDate ? `${j.startDate} – ${j.endDate}` : `${j.startDate} – Present`;
        const hi = (j.highlights||[]).map(x => `<li>${x}</li>`).join('');
        return `
          <div style="margin:10px 0;">
            <div style="display:flex;justify-content:space-between;gap:12px;flex-wrap:wrap;">
              <strong>${j.position}</strong> @ ${j.name}
              <span style="color:#666;">${when}</span>
            </div>
            ${j.summary ? `<div style="margin:4px 0 0;">${j.summary}</div>` : ''}
            ${hi ? `<ul style="margin:6px 0 0 18px;">${hi}</ul>` : ''}
          </div>`;
      }).join('');
      byId('work').innerHTML = work;

      const skills = (data.skills||[]).map(s => `<span class="chip">${s.name}${s.keywords?.length ? ' — ' + s.keywords.join(', ') : ''}</span>`).join('');
      byId('skills').innerHTML = skills;

      // Inform parent iframe of height
      requestAnimationFrame(() => {
        const h = document.documentElement.scrollHeight;
        window.parent && window.parent.postMessage({ type: 'variant:height', value: h }, '*');
      });
    }
    render();
  </script>
</body>
</html>
```

---

## 6) Reproducible prompt template (paste into each tool)

Create `prompts/variant-template.md` in your repo (and paste this when generating):

````markdown
You are generating a single-file variant of my resume website for the tool showcase
“See this website made with <TOOL>”. Deliver **one production-ready HTML file** named `index.html`.
It will be hosted at `/variants/<tool>/index.html` on the same origin as `/data/resume.json`.

**Requirements**
- **Data source**: Fetch `/data/resume.json` and render the resume. No other network calls.
- **Self-contained**: Inline CSS and JS inside the HTML (no external fonts, no trackers).
- **Namespace**: Wrap all HTML within a top-level container with id `app-<tool>` to avoid CSS/JS leaks.
- **A11y**: Semantic HTML, good contrast, keyboard-friendly.
- **Performance**: Mobile-first; aim Lighthouse ≥ 90 without external assets.
- **Height messaging**: After render, notify parent iframe for auto-resize:
  ```js
  requestAnimationFrame(() => {
    const h = document.documentElement.scrollHeight;
    window.parent && window.parent.postMessage({ type: 'variant:height', value: h }, '*');
  });
````

**Visual direction**

* Feel free to be “fancy” (animations, layout, cards) but keep it tasteful.
* Do not import external fonts; use system-ui stack.
* Use a small accent color and subtle shadows; avoid heavy backgrounds.

**Content to show**

* Header: name, label, quick links (Website, Email, GitHub, LinkedIn)
* Summary
* Experience (title @ org, dates, summary, highlights)
* Projects (name, link, short desc)
* Skills (grouped chips)
* Optional: “Generated with <TOOL> on <DATE>” line in the footer.

**Delivery**

* Output only the full HTML for `index.html`.

```

> When you paste this into Lovable, Bolt, Cursor, ChatGPT, Claude Code, or v0, also provide the JSON from `/static/data/resume.json` (or link to it if the tool can fetch local files). Save the resulting `index.html` under `static/variants/<tool>/`.

---

## 7) Next steps & tips

- **Add more variants**: Create `static/variants/lovable/index.html`, etc. Run `npm run validate:variants`.
- **Prefetch**: We already add `<link rel="prefetch">` for the selected variant. You can duplicate that for your most popular ones on the home page if you want instant swaps.
- **CSP** (optional hardening): In production, add a CSP header `default-src 'self'` for the shell. Variants run in a sandboxed iframe.
- **Noindex**: Variants are disallowed in `robots.txt` and also use meta `noindex` when viewed via `/with/[tool]`.

If you want, I can tailor the `resume.json` with your exact roles (AI engineering + enablement), or wire simple Lighthouse CI badges per-variant.
```
</assistant>